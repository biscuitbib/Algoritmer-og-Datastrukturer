\section{Balancerede Binære Søgetræer}
\hrulefill

\begin{itemize}
\item Operationer på et binært søgetræ
  \begin{itemize}
  \item Trævandring
  \item Søgning på et binært søgetræ
  \item Indsættelse og sletning
  \end{itemize}
\item Rød-sort træ - Balanceret binært søgetræ
\item Krydsende linjesegmenter
\end{itemize}

\newpage
\subsection{Operationer på et binært søgtræ}

\subsubsection{Trævandring}

\begin{theorem}
  Lad $x$ være en rod til deltræ med $n$ knuder, så vil et kald til en trævandringsfunktion e.g. \texttt{INORDER-TREE-WALK($x$)} tage $\Theta(n)$ tid.
\end{theorem}

\begin{proof}
  Det er let at se at det er $\Omega(n)$, da vi skal besøge alle $n$ knuder, så vi mangler bare at vise at den er $Ø(n)$.\\

  Vi siger at prisen for at lave checket ($x \neq$\texttt{NIL}) er $c>0$, så $T(0) = c$. For $n > 0$ lader vi $x$ have to børn, så $x.left.size = k$ og $x.right.size = n - k - 1$, så er tiden for træet
  $$T(n) \leq T(k) + T(n-k-1) + d$$
  Hvor $d > 0$ er tiden det tager for indmaden i algoritmen e.g. \texttt{PRINT}.\\
  
  Vi viser nu $T(n) = Ø(n)$ ved at bruge substitutionsmetoden til at vise $T(n) \leq (c+d)n + c$ ($T(n)$ er det første test plus indmaden for hvert rekursivt kald, plus den sidste test når $n=0$):\\
  Først viser vi base-case
  \begin{align*}
    T(0) &= c \leq (c + d)0 + c\\
         &= c \leq c
  \end{align*}
  Nu antager vi at $T(m) \leq (c+d)m + c$ for $m < n$
  \begin{align*}
    T(n) &\leq T(k) + T(n-k-1) + d \leq (c+d)n + c\\
         &= ((c+d)k + c) + ((c+d)(n-k-1) + c) + d \leq (c+d)n + c\\
         &= ck + dk + c + cn - ck - c + dn - dk - d + c + d \leq (c+d)n + c\\
         &= cn + dn + c  \leq (c + d)n + c\\
  \end{align*}

  Vi har nu vist at $T(n) = \Omega(n)$ og $T(n) = Ø(n)$, ergo $T(n) = \Theta(n)$.
\end{proof}

\subsubsection{Søgning på et binært træ}

\begin{theorem}
  Søgningsoperationerne \texttt{SEARCH, MINIMUM, MAXIMUM, SUCCESSOR,} og \texttt{PREDECESSOR} har alle en køretid på $Ø(h)$ på et binært søgetræ med højde $h$.
\end{theorem}

\begin{proof}
  I \texttt{SEARCH($x$)} kan vi, på grund af binær søgetræsegenskaben, følge en simpel path fra roden til knuden $x$, ved at se om $x$ er større eller mindre end den nuværende knude. Siden en simpel path er $Ø(h)$ er \texttt{SEARCH} $= Ø(h)$.\\

  \texttt{MINIMUM} og \texttt{MAXIMUM} er endnu lettere. På grund af binær søgetræsegenskaben, er den mindste knude bladet længst til venstre, og den største knude er bladet længst til højre. Igen er det en simpel path som er $Ø(h)$.\\

  \texttt{PREDECESSOR} og \texttt{SUCCESSOR} er lidt mere komplicerede. Her udnytter vi også binær søgetræsegenskaben. For at finde den mindste knude der er større end $x$, er der to tilfælde at tage højde for. Hvis $x$ højre deltræ findes, så er den næste knude den mindste knude i højre deltræ, som vi kan finde i $Ø(h)$ tid. Hvis ikke, så går vi iterativt op til vores forælder, indtil vores forælder er et venstre barn af en knude, hvorefter vi returnerer vores bedsteforælder. I værste tilfælde skal vi følge en simpel path fra et blad til roden, hvilket også er $Ø(h)$. Det er symmetrisk at finde den største knude der er mindre end $x$.\\

  Vi har nu vist at alle søgningsoperationer er $Ø(h)$ på et binært søgetræ med højde $h$.
\end{proof}

\subsubsection*{Indsættelse og sletning}

\begin{theorem}
  Vi kan implementerer \texttt{INSERT} og \texttt{DELETE} i $Ø(h)$ tid, på et binært søgetræ med højde $h$.
\end{theorem}

\begin{proof}
  
\end{proof}

\subsection{Rød-sort træ - Balanceret binært søgetræ}

\begin{lemma}
  Et rødt-sort træ med $n$ knuder har en højde på højst $2lg(n+1) = Ø(lgn)$
\end{lemma}

\begin{proof}
  Vi starter med at vise, at et deltræ med rod $x$ har $2^{bh(x)}- 1$ knuder. Vi beviser det med induktion på højden af deltræet.\\
  Hvis $h=0$ har vi at $x$ må være et blad og deltræet under $x$ har derfor
  $$2^{bh(x)} - 1 = 2^o - 1 = 1 - 1 = 0$$
  knuder under sig.\\

  Hvis $h > 0$, er $x$ roden til et deltræ og har to børn, som hver især har enten $bh(x)$ eller $bh(x) - 1$, hvis de er henholdsvis røde eller sorte. Det betyder også, at hvert af børnenes deltræer har mindst $2^{bh(x)-1}-1$ knuder under sig, og $x$ har derfor
  $$(2^{bh(x)-1} - 1) + (2^{bh(x)-1} - 1) + 1 = 2^{bh(x)} - 1$$
  knuder under sig, og vi har nu vist den første påstand.\\

  For at færdiggøre beviset, lad vi højden af træet være $h$. Ifølge den 4. rød-sort egenskab, er mindst halvdelen af knuderne, eksklusiv roden, i en simpel path ned af træet, sorte. Derved er $bh(x)$ af roden $x$ mindst $\frac{h}{2}$, og vi har derfor
  \begin{align*}
           n &\geq 2^{\frac{h}{2}} - 1\\
       n + 1 &\geq 2^{\frac{h}{2}}\\
     lg(n+1) &\geq \frac{h}{2}\\
    2lg(n+1) &\geq h
  \end{align*}

  Ergo har vi vist at højden er $h$ er højst $2lg(n+1)$ og derved $h=Ø(lgn)$.
\end{proof}
\subsection{Krydsende linjesegmenter}
Hvis man har en mængde linjesegmenter og man ønsker at finde ud af om nogen af linjesegmenterne krydser hinanden kan man bruge en metode kaldet \textbf{sweeping}.\\
Sweeping algoritmen bruger en lodret \textbf{sweep line} som kører over mængden af linjesegmenter, og vi betegner den dimension som sweep line bevæger sig over, $x$-aksen, en dimension af tid. Vi antager to ting om vores linjesegmenter, ingen af linjesegmenterne er lodrette linjer, og højst to linjesegmenter kan overlappe på et punkt.\\

Vi bestemmer en relation $\succeq$ mellem to segmenter $s_1$ og $s_2$ i forhold til deres $y$ position ved et bestemt tidspunkt. Vi siger at $s_1 \succeq_x s_2$, hvis $s_1$ ligger højere end $s_2$ ved tidspunkt $x$.
\begin{figure}[H]
  \centering
  \caption{Linjesegmenter og sweep line ved tidspunkt $x_1$ og $x_2$}
  \begin{tikzpicture}
    \draw[dashed] (0.5 , 4) -- (0.5,-1) node[below] {$x_1$};
    \draw[dashed] (3 , 4) -- (3,-1) node[below] {$x_2$};
    \draw (0,1) -- (3.5,1.5) node[anchor=north] {$s_2$};
    \draw (0,2) -- (4, 0) node[anchor=north] {$s_1$};
  \end{tikzpicture}
\end{figure}

Som kan ses på figur 2, så er $s_1 \succeq_{x_1} s_2$ og $s_2 \succeq_{x_2} s_1$.\\
Vi holder styr på forholdene mellem alle segmenterne, i en rangeret orden. Et segment kommer med i ordenen når sweep line passere segmentets venstre ende, og den bliver taget ud af ordenen når sweep line passere dens højre ende.\\

Når to linjesegmenter krydser hinanden kan det ses på deres forhold før og efter sweep line har passeret deres krydsningspunkt. Hvis vi har to segmenter $e, f$, så vil $e \succeq_v f$, hvor $v$ er tidspunket før krydset, og $f \succeq_w e$, hvor $w$ er tidspunktet efter krydset. Præcis i krydsningspunktet vil både $e \succeq f$ og $f \succeq e$.\\

Selve sweep algoritmen sorterer alle linjesegmenterne i forhold deres ender, således at de venstre endepunkter kommer før de højre, hvis de er ens så kommer den med laveste $y$-værdi først. Vi holder styr på dette i et rød-sort træ, hvor, når vi sammenligner knuder i træet, laver vi krydsprodukt mellem to linjesegmenters endepunkter.\\

Algoritmen til at finde krydsende linjesegmenter bruger 4 hjælpefunktioner til rød-sort træet:
\begin{itemize}
\item \texttt{INSERT($T,s$)} indsætter linjesegment $s$ i træet $T$
\item \texttt{DELETE($T,s$)} fjerner linjesegment $s$ fra træet $T$
\item \texttt{ABOVE($T,s$)} returnere linjesegmentet over $s$, således at $s' \succeq s$
\item \texttt{BELOW($T,s$)} returnere linjesegmentet under $s$, således at $s \succeq s'$
\end{itemize}

\begin{algorithm}[H]
  \caption{Algoritme der finder krydsende linjesegmenter}
  \begin{algorithmic}[1]
    \State $S$ en mængde af $n$ linjesegmenter
    \Function{ANY-SEGMENTS-INTERSECT}{$S$}
    \State $T =$ Rød-sort træ
    \State Sorter alle linjesegmenternes endepunkter, venstre før højre, lavest før højest.
    \For{\textbf{each} endepunkt $p$ i den sorterede liste}
    \If{$p$ er venstre endepunkt af linjesegment $s$}
    \State INSERT($T,s$)
    \If{(ABOVE($T,s$) findes og krydser $s$) \textbf{or} (BELOW($T,s$) findes og krydser $s$))}
    \State \textbf{return} TRUE 
    \EndIf
    \EndIf
    \If{$p$ er højre endepunkt af linjesegment $s$}
    \If{både ABOVE($T,s$) og BELOW($T,s$) findes, og ABOVE($T,s$) krydser BELOW($T,s$)}
    \State \textbf{return} TRUE
    \EndIf
    \State DELETE($T,s$)
    \EndIf
    \EndFor
    \State \textbf{return} FALSE
    \EndFunction
  \end{algorithmic}
\end{algorithm}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "master"
%%% End:
